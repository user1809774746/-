# 帖子发布错误根因分析

## 问题摘要

前端调用 `/api/post/create` 接口时返回 400 错误，后端日志显示：
```
Field 'title' doesn't have a default value
SQL Error: 1364, SQLState: HY000
```

## 错误追踪

### 1. 错误发生位置

从后端日志可以看到错误发生在保存 `UserTravelPost` 实体时：

```
2025-10-29 15:44:34.192  INFO 4084 --- [io-8081-exec-10] c.example.auth.service.UserPostService   : 开始创建帖子，用户: 18831231517
...
2025-10-29 15:44:34.235  INFO 4084 --- [io-8081-exec-10] c.example.auth.service.UserPostService   : travel_post主表记录创建成功，ID: 5
Hibernate:
    insert
    into
        user_travel_post
        (created_time, is_original, is_pinned, publisher_avatar_url, publisher_id, publisher_nickname, travel_post_id, updated_time, user_category, user_deleted_time, user_notes, user_published_time, user_status, user_tags)
    values
        (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
2025-10-29 15:44:34.247  WARN 4084 --- [io-8081-exec-10] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1364, SQLState: HY000
2025-10-29 15:44:34.253 ERROR 4084 --- [io-8081-exec-10] o.h.engine.jdbc.spi.SqlExceptionHelper   : Field 'title' doesn't have a default value
```

### 2. 代码执行流程

根据 `UserPostService.java` 的 `createPost` 方法（第50-88行）：

```java
@Transactional
public PostResponse createPost(String phone, PostCreateRequest request) {
    // 1. 首先创建TravelPost主表记录 ✅ 成功
    TravelPost travelPost = new TravelPost();
    copyRequestToTravelPost(request, travelPost);
    travelPost.setPublisherId(user.getUserId());
    travelPost.setStatus("draft");
    travelPost.setAuditStatus("pending");
    
    TravelPost savedTravelPost = travelPostRepository.save(travelPost);
    logger.info("travel_post主表记录创建成功，ID: {}", savedTravelPost.getId()); // ✅ 成功，ID=5
    
    // 2. 然后创建UserTravelPost关联记录 ❌ 失败
    UserTravelPost userPost = new UserTravelPost();
    userPost.setTravelPostId(savedTravelPost.getId());
    userPost.setPublisherId(user.getUserId());
    userPost.setPublisherNickname(user.getNumber());
    userPost.setUserStatus("draft");
    userPost.setIsOriginal(request.getIsOriginal() != null ? request.getIsOriginal() : true);
    
    UserTravelPost savedUserPost = userPostRepository.save(userPost); // ❌ 这里失败
}
```

### 3. 根本原因分析

#### 问题根源
数据库中的 `user_travel_post` 表结构与代码中的 `UserTravelPost` 实体类不匹配！

#### UserTravelPost 实体类定义（UserTravelPost.java）
```java
@Entity
@Table(name = "user_travel_post")
@Data
public class UserTravelPost {
    private Long id;
    private Long travelPostId; // 关联到travel_post表
    private Long publisherId;
    private String publisherNickname;
    private String publisherAvatarUrl;
    private String userStatus;
    private Boolean isOriginal;
    private String userNotes;
    private String userTags;
    private Boolean isPinned;
    private String userCategory;
    private Date createdTime;
    private Date updatedTime;
    private Date userPublishedTime;
    private Date userDeletedTime;
}
```

**注意**：实体类中**没有** `title` 字段！

#### 数据库表结构（推测）
根据错误信息和历史SQL文件（如 `create_post_tables_fixed.sql`），数据库中的 `user_travel_post` 表很可能包含了：
```sql
CREATE TABLE user_travel_post (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    publisher_id BIGINT NOT NULL,
    publisher_nickname VARCHAR(100),
    publisher_avatar_url VARCHAR(500),
    
    title VARCHAR(200) NOT NULL,  -- ❌ 这个字段不应该存在！
    summary LONGTEXT,              -- ❌ 这个字段不应该存在！
    content LONGTEXT NOT NULL,     -- ❌ 这个字段不应该存在！
    content_type VARCHAR(20),      -- ❌ 这个字段不应该存在！
    ...
    -- 以及更多帖子内容字段
);
```

#### 架构设计冲突

**旧的单表结构**（错误的）：
- `user_travel_post` 表包含所有帖子内容字段（title、content等）

**新的双表结构**（正确的）：
- `travel_post` 表：存储帖子内容（title、content、summary等）
- `user_travel_post` 表：只存储用户与帖子的关联关系

#### 为什么会报错

1. Hibernate 根据 `UserTravelPost` 实体类生成 INSERT 语句
2. INSERT 语句**不包含** `title` 字段（因为实体类中没有）
3. 数据库中的 `title` 字段被定义为 `NOT NULL` 且没有默认值
4. MySQL 拒绝执行这个 INSERT 语句，报错：`Field 'title' doesn't have a default value`

## 解决方案

### 核心解决方法：修正数据库表结构

数据库中的 `user_travel_post` 表必须与 `UserTravelPost` 实体类保持一致。

### 选项1：重建表（推荐，干净彻底）

执行 `fix_user_travel_post_table.sql`：
- 备份现有表
- 删除旧表
- 创建符合实体类定义的新表

### 选项2：删除多余字段（保守方式）

执行 `fix_user_travel_post_remove_fields.sql`：
- 删除所有帖子内容相关字段
- 保留用户关联和状态字段

## 修复后的正确表结构

```sql
CREATE TABLE user_travel_post (
    -- 主键
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    
    -- 关联字段
    travel_post_id BIGINT NOT NULL,          -- ✅ 关联到travel_post表
    publisher_id BIGINT NOT NULL,
    
    -- 发布者信息
    publisher_nickname VARCHAR(100),
    publisher_avatar_url VARCHAR(500),
    
    -- 用户特定字段
    user_status VARCHAR(20) DEFAULT 'active',
    is_original BOOLEAN DEFAULT TRUE,
    user_notes LONGTEXT,
    user_tags VARCHAR(500),
    is_pinned BOOLEAN DEFAULT FALSE,
    user_category VARCHAR(50),
    
    -- 时间戳
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    user_published_time DATETIME,
    user_deleted_time DATETIME,
    
    -- 索引和约束
    FOREIGN KEY (travel_post_id) REFERENCES travel_post(id) ON DELETE CASCADE,
    FOREIGN KEY (publisher_id) REFERENCES user_info(UserID) ON DELETE CASCADE,
    UNIQUE INDEX idx_travel_post_publisher (travel_post_id, publisher_id)
);
```

## 双表架构的优势

### travel_post 表（主表）
- 存储帖子的完整内容
- 一个帖子记录可以被多个用户引用（如果将来支持转发功能）
- 统一管理帖子的审核状态、点赞数、评论数等

### user_travel_post 表（关联表）
- 存储用户与帖子的关联
- 用户可以对同一个帖子有不同的状态（如隐藏、置顶）
- 用户可以添加私人备注和标签
- 支持软删除（用户删除不影响原帖子）

## 执行步骤

1. **备份数据库**（重要！）
   ```sql
   -- 备份整个数据库
   mysqldump -u root -p gd_mcp > gd_mcp_backup_$(date +%Y%m%d_%H%M%S).sql
   ```

2. **执行修复SQL**
   - 使用数据库管理工具连接到 `gd_mcp` 数据库
   - 执行 `fix_user_travel_post_remove_fields.sql` 或 `fix_user_travel_post_table.sql`

3. **验证表结构**
   ```sql
   DESCRIBE user_travel_post;
   ```

4. **重启Spring Boot应用**
   ```bash
   # 在项目根目录
   mvn spring-boot:run
   ```

5. **测试帖子发布功能**
   - 使用前端页面测试
   - 或使用Postman/Apifox测试 `/api/post/create` 接口

## 预期结果

修复后，帖子创建流程应该是：

1. ✅ 创建 `travel_post` 主表记录（保存帖子内容）
2. ✅ 创建 `user_travel_post` 关联记录（保存用户关联）
3. ✅ 返回成功响应

日志应该显示：
```
INFO: 开始创建帖子，用户: 18831231517
INFO: travel_post主表记录创建成功，ID: 5
INFO: user_travel_post关联记录创建成功，ID: 1
```

## 后续建议

1. **统一SQL脚本管理**
   - 将所有表结构定义放在统一的SQL文件中
   - 使用数据库迁移工具（如Flyway或Liquibase）

2. **实体类与数据库同步**
   - 确保实体类与数据库表结构完全一致
   - 定期检查和验证

3. **开发环境隔离**
   - 使用独立的开发数据库
   - 避免直接修改生产数据库

4. **添加集成测试**
   - 为帖子创建功能添加单元测试和集成测试
   - 及早发现实体类与数据库不匹配的问题

